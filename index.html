<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - loaders - MMD loader</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <style>
        body {
            background-color: #fff;
            color: #444;
        }

        a {
            color: #08f;
        }
    </style>
</head>

<body>
<div id="info"></div>

<script src="js/libs/ammo.wasm.js"></script>
<script src="scoreoutputer.min.js"></script>
<script>
    // 建構子 ScoreOutputer 接受一個字串，該字串為 csv 的檔案名稱
    // 以下面範例，檔名就為 "109598105(總分: 6).csv"
    var so = new ScoreOutputer("109598105");
    so.installCSS(function () {
        // 安裝 bootstrap 的 css，如果在 html 上方引用 bootstrap 5.1.1 的話就不用使用 installCSS ，注意一定要 bootstrap css 5.1.1 版
        // installCSS 接收一個 callback 當作參數，作為成功安裝 bootstrap css 的回呼函式

        //加入項目，分數，完成狀況
        //第一個參數為 項目名稱
        //第2個參數為 項目分數
        //第3個參數為 完成狀況，有完成 true/未完成 false
        //有幾個項目就呼叫幾個 addChild
        //addChild 要比 renderModal 先呼叫
        so.addChild("繪製出 5 個畫面", 1, true);
        so.addChild("回答問題", 1, false);
        so.addChild("可按鍵選擇上 / 下一隻角色", 1, false);
        so.addChild("讀取作業 2 儲存的座標點在眼睛上繪製出分割線", 1, false);
        so.addChild("可選擇當下控制哪個虹膜", 1, false);
        so.addChild("按滑鼠左鍵控制虹膜移動，右鍵停止", 2, false);
        so.addChild("複製參數至對應目標參數", 2, false);
        so.addChild("可儲存虹膜轉動角度", 1, false);

        //產生自評表，參數如下所示
        so.renderModal(
            //1. 自評表插入位置 (預設 document.body)
            document.body,
            //2. 自評表背景 (預設紅色)
            'rgba(100,45,58,1)',
            //3. 自評表文字顏色 (預設白色)
            'white',
            //4. 自評表文字大小 (預設 14pt)
            '15pt',
            //5. 自評表 checkbox 文字大小 (預設多少忘了)
            '15px',
            //6. 自評表標題 (預設 "自我評分表")
            dialogTitle = "自我評分表"
        );

        //設定下載按鈕 <-- 一定要呼叫這個函數，不然沒有下載功能
        so.installDownloadBtn();

        //產生 "開啟自評表按鈕"
        so.renderBtn(
            //自評表按鈕插入位置
            document.querySelector("#info"),
            //自評表按鈕文字
            "開啟自評表"
        );
    });
</script>
<script type="module">

    import * as THREE from './build/three.module.js';
    import {GUI} from './jsm/libs/dat.gui.module.js';
    import {OrbitControls} from './jsm/controls/OrbitControls.js';
    import {OutlineEffect} from './jsm/effects/OutlineEffect.js';
    import {MMDLoader} from './jsm/loaders/MMDLoader.js';
    import {MMDAnimationHelper} from './jsm/animation/MMDAnimationHelper.js';

    let scene, renderer, effect;
    let mesh, helper;
    let SCREEN_WIDTH = window.innerWidth;
    let SCREEN_HEIGHT = window.innerHeight;
    let aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
    let frustumSize = 1.5;

    let mouse = new THREE.Vector2();
    let mouseDownPos = new THREE.Vector2();
    let isMouseDown = false;

    let modelDataList = [];
    let currentModelIdx = 0;

    let mainView;
    let subViews = [];
    let currentViewIdx = 0;

    let subViewCameraPositions = [];
    let modelPositions = [];

    let currentModelEyeIdx = 0;

    Ammo().then(function (AmmoLib) {

        Ammo = AmmoLib;

        init();
        animate();

    });

    function init() {
        const container = document.createElement('div');
        document.body.appendChild(container);

        // set scene
        scene = new THREE.Scene();

        // set light
        const ambient = new THREE.AmbientLight(0x666666);
        scene.add(ambient);
        const directionalLight = new THREE.DirectionalLight(0x887766);
        directionalLight.position.set(-1, 1, 1).normalize();
        scene.add(directionalLight);

        // set render
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);
        renderer.autoClear = false;
        effect = new OutlineEffect(renderer);

        // read view
        mainView = readMainView();
        subViews = readSubViews();

        // load data and model
        loadJSON('model_data.json', function (json) {
            modelDataList = JSON.parse(json)['modelList'];

            // read positions
            subViewCameraPositions = readPositions(modelDataList, 'subViewCameraPosition');
            modelPositions = readPositions(modelDataList, 'modelPosition');

            // load model
            loadModel(currentModelIdx, currentViewIdx);
        })

        // set event listener
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('resize', onWindowResize);
    }

    function readMainView() {
        return {
            camera: createOrthographicCamera(),
            model: null,
            eyeRotation: [
                {
                    x: 0,
                    y: 0
                },
                {
                    x: 0,
                    y: 0
                }
            ],
            viewport: {
                x: 0,
                y: 0,
                w: SCREEN_WIDTH / 2,
                h: SCREEN_HEIGHT
            }
        }
    }

    function readSubViews() {
        return [
            {
                camera: createOrthographicCamera(),
                eyeRotation: [
                    {
                        x: -0,
                        y: 0
                    },
                    {
                        x: -0,
                        y: 0
                    }
                ],
                viewport: {
                    x: SCREEN_WIDTH / 2,
                    y: SCREEN_HEIGHT / 2,
                    w: SCREEN_WIDTH / 4,
                    h: SCREEN_HEIGHT / 2
                }
            },
            {
                camera: createOrthographicCamera(),
                eyeRotation: [
                    {
                        x: -0,
                        y: 0
                    },
                    {
                        x: -0,
                        y: 0
                    }
                ],
                viewport: {
                    x: SCREEN_WIDTH / 2 + SCREEN_WIDTH / 4,
                    y: SCREEN_HEIGHT / 2,
                    w: SCREEN_WIDTH / 4,
                    h: SCREEN_HEIGHT / 2
                }
            },
            {
                camera: createOrthographicCamera(),
                eyeRotation: [
                    {
                        x: -0,
                        y: 0
                    },
                    {
                        x: -0,
                        y: 0
                    }
                ],
                viewport: {
                    x: SCREEN_WIDTH / 2,
                    y: 0,
                    w: SCREEN_WIDTH / 4,
                    h: SCREEN_HEIGHT / 2
                }
            },
            {
                camera: createOrthographicCamera(),
                eyeRotation: [
                    {
                        x: -0,
                        y: 0
                    },
                    {
                        x: -0,
                        y: 0
                    }
                ],
                viewport: {
                    x: SCREEN_WIDTH / 2 + SCREEN_WIDTH / 4,
                    y: 0,
                    w: SCREEN_WIDTH / 4,
                    h: SCREEN_HEIGHT / 2
                }
            }
        ]
    }

    function readPositions(modelDataList, propName) {
        let positions = [];
        let pos;
        let z = propName === 'subViewCameraPosition' ? frustumSize : 0

        modelDataList.forEach(function (modelData) {
            pos = modelData[propName];
            positions.push(new THREE.Vector3(0, pos.y, z))
        })

        return positions
    }

    function setMainViewCamera(viewIdx) {
        mainView.camera.position.copy(subViews[viewIdx].camera.position);
        mainView.camera.position.x = modelDataList[currentModelIdx].mainViewCameraPosition[currentModelEyeIdx].x;
        mainView.camera.position.y = modelDataList[currentModelIdx].mainViewCameraPosition[currentModelEyeIdx].y;
    }

    function setSubViewCameraPositions(modelIdx) {
        subViews.forEach(function (view) {
            view.camera.position.copy(subViewCameraPositions[modelIdx]);
        });
    }

    function setEyeRotation(dx, dy) {
        subViews[currentViewIdx].eyeRotation[currentModelEyeIdx].x = -dy * 2;
        subViews[currentViewIdx].eyeRotation[currentModelEyeIdx].y = dx * 2;
    }

    function updateCurrentModelIdx(offset) {
        currentModelIdx = (currentModelIdx + offset + modelDataList.length) % modelDataList.length;
    }

    function moveEyeLines(offset) {
        let eyeLength = 2;
        let nextModelEyeIdx = currentModelEyeIdx + offset;

        if (nextModelEyeIdx < 0 ){
            currentViewIdx = (currentViewIdx - 1 + subViews.length) % subViews.length
        }

        if (nextModelEyeIdx > 1){
            currentViewIdx = (currentViewIdx + 1 + subViews.length) % subViews.length
        }

        currentModelEyeIdx = (nextModelEyeIdx + eyeLength) % eyeLength;

        setMainViewCamera(currentViewIdx);
    }

    function createOrthographicCamera() {
        return new THREE.OrthographicCamera(
            0.5 * frustumSize * aspect / -2,
            0.5 * frustumSize * aspect / 2,
            frustumSize / 2,
            frustumSize / -2,
            0.1,
            1000
        );
    }

    function loadJSON(file, callback) {
        let xObj = new XMLHttpRequest();
        xObj.overrideMimeType("application/json");
        xObj.open('GET', file, true);
        xObj.onreadystatechange = function () {
            if (xObj.readyState === 4 && xObj.status === 200) {
                callback(xObj.responseText);
            }
        };
        xObj.send(null);
    }

    function loadModel(modelIdx, viewIdx) {
        function onProgress(xhr) {
            if (xhr.lengthComputable) {
                const percentComplete = xhr.loaded / xhr.total * 100;
                console.log(Math.round(percentComplete, 2) + '% downloaded');
            }
        }

        let modelFile = modelDataList[modelIdx].modelPath;

        helper = new MMDAnimationHelper();

        const loader = new MMDLoader();

        loader.load(modelFile, function (object) {
            if (mainView.model !== null) scene.remove(mainView.model);
            mainView.model = object;
            mainView.model.position.copy(modelPositions[modelIdx]);
            scene.add(mainView.model);

            // set camera positions and set main view came
            setSubViewCameraPositions(modelIdx);
            setMainViewCamera(viewIdx);

        }, onProgress, null);
    }

    function onKeyDown(event) {
        if (event.key === 'A' || event.key === 'a') {
            updateCurrentModelIdx(-1);
            loadModel(currentModelIdx, currentViewIdx);
        }

        if (event.key === 'D' || event.key === 'd') {
            updateCurrentModelIdx(1);
            loadModel(currentModelIdx, currentViewIdx);
        }

        if (event.key === '2') {
            moveEyeLines(1)
        }

        if (event.key === '1') {
            moveEyeLines(-1)
        }
    }

    function onMouseMove(event) {
        if (!isMouseDown) return;
        event.preventDefault();
        let dx = (event.clientX / window.innerWidth) * 2 - 1 - mouse.x;
        let dy = -(event.clientY / window.innerHeight) * 2 + 1 - mouse.y;
        setEyeRotation(dx, dy);
    }

    function onMouseDown(event) {
        if (event.button === 2) return;
        event.preventDefault();
        isMouseDown = true;
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    function onMouseUp(event) {
        event.preventDefault();
        isMouseDown = false;
    }

    function onWindowResize() {
        SCREEN_WIDTH = window.innerWidth;
        SCREEN_HEIGHT = window.innerHeight;
        aspect = SCREEN_WIDTH / SCREEN_HEIGHT;

        effect.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

        mainView.camera.left = 0.5 * frustumSize * aspect / -2;
        mainView.camera.right = 0.5 * frustumSize * aspect / 2;
        mainView.camera.top = frustumSize / 2;
        mainView.camera.bottom = -frustumSize / 2;
        mainView.camera.updateProjectionMatrix();

        subViews.forEach(function (view) {
            view.camera.left = 0.25 * frustumSize * aspect / -2;
            view.camera.right = 0.25 * frustumSize * aspect / 2;
            view.camera.top = 0.5 * frustumSize / 2;
            view.camera.bottom = -0.5 * frustumSize / 2;
            view.camera.updateProjectionMatrix();
        })
    }

    function animate() {
        requestAnimationFrame(animate);
        render();
    }

    function render() {

        effect.clear();

        let mesh = mainView.model;

        if (!mesh) return;

        setMainViewEffect();
        setSubViewEffect();
    }

    function setMainViewEffect() {
        let eyeBoneIdxes = modelDataList[currentModelIdx].eyeBoneIdxes;
        eyeBoneIdxes.forEach(function (eyeBoneIdx, i) {
            mainView.model.skeleton.bones[eyeBoneIdx].rotation.x = subViews[currentViewIdx].eyeRotation[i].x;
            mainView.model.skeleton.bones[eyeBoneIdx].rotation.y = subViews[currentViewIdx].eyeRotation[i].y;
        });

        effect.setViewport(
            mainView.viewport.x,
            mainView.viewport.y,
            mainView.viewport.w,
            mainView.viewport.h
        );
        effect.render(scene, mainView.camera);
    }

    function setSubViewEffect() {
        let eyeBoneIdxes = modelDataList[currentModelIdx].eyeBoneIdxes;
        subViews.forEach(function (view) {
            eyeBoneIdxes.forEach(function (eyeBoneIdx, i) {
                mainView.model.skeleton.bones[eyeBoneIdx].rotation.x = view.eyeRotation[i].x;
                mainView.model.skeleton.bones[eyeBoneIdx].rotation.y = view.eyeRotation[i].y;
            });

            effect.setViewport(
                view.viewport.x,
                view.viewport.y,
                view.viewport.w,
                view.viewport.h
            );
            effect.render(scene, view.camera);
        })
    }

</script>

</body>

</html>