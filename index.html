<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - loaders - MMD loader</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <style>
        body {
            background-color: #fff;
            color: #444;
        }

        a {
            color: #08f;
        }
    </style>
</head>

<body>
<div id="info"></div>

<script src="js/libs/ammo.wasm.js"></script>
<script src="scoreoutputer.min.js"></script>
<script>
    // 建構子 ScoreOutputer 接受一個字串，該字串為 csv 的檔案名稱
    // 以下面範例，檔名就為 "109598105(總分: 6).csv"
    var so = new ScoreOutputer("110598045");
    so.installCSS(function () {
        // 安裝 bootstrap 的 css，如果在 html 上方引用 bootstrap 5.1.1 的話就不用使用 installCSS ，注意一定要 bootstrap css 5.1.1 版
        // installCSS 接收一個 callback 當作參數，作為成功安裝 bootstrap css 的回呼函式

        //加入項目，分數，完成狀況
        //第一個參數為 項目名稱
        //第2個參數為 項目分數
        //第3個參數為 完成狀況，有完成 true/未完成 false
        //有幾個項目就呼叫幾個 addChild
        //addChild 要比 renderModal 先呼叫
        so.addChild("繪製出 5 個畫面", 1, true);
        so.addChild("回答問題", 1, false);
        so.addChild("可按鍵選擇上 / 下一隻角色", 1, true);
        so.addChild("讀取作業 2 儲存的座標點在眼睛上繪製出分割線", 1, false);
        so.addChild("可選擇當下控制哪個虹膜", 1, false);
        so.addChild("按滑鼠左鍵控制虹膜移動，右鍵停止", 2, false);
        so.addChild("複製參數至對應目標參數", 2, false);
        so.addChild("可儲存虹膜轉動角度", 1, false);

        //產生自評表，參數如下所示
        so.renderModal(
            //1. 自評表插入位置 (預設 document.body)
            document.body,
            //2. 自評表背景 (預設紅色)
            'rgba(100,45,58,1)',
            //3. 自評表文字顏色 (預設白色)
            'white',
            //4. 自評表文字大小 (預設 14pt)
            '15pt',
            //5. 自評表 checkbox 文字大小 (預設多少忘了)
            '15px',
            //6. 自評表標題 (預設 "自我評分表")
            dialogTitle = "自我評分表"
        );

        //設定下載按鈕 <-- 一定要呼叫這個函數，不然沒有下載功能
        so.installDownloadBtn();

        //產生 "開啟自評表按鈕"
        so.renderBtn(
            //自評表按鈕插入位置
            document.querySelector("#info"),
            //自評表按鈕文字
            "開啟自評表"
        );
    });
</script>
<script type="module">

    import * as THREE from './build/three.module.js';
    import {GUI} from './jsm/libs/dat.gui.module.js';
    import {OrbitControls} from './jsm/controls/OrbitControls.js';
    import {OutlineEffect} from './jsm/effects/OutlineEffect.js';
    import {MMDLoader} from './jsm/loaders/MMDLoader.js';
    import {MMDAnimationHelper} from './jsm/animation/MMDAnimationHelper.js';

    let scene, renderer, effect;
    let mesh, helper;
    let SCREEN_WIDTH = window.innerWidth;
    let SCREEN_HEIGHT = window.innerHeight;
    let aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
    let frustumSize = 3;
    let camera, camera2, camera3, camera4, camera5;
    let cameraPos = new THREE.Vector3(0,8.1,3);
    let cameraLookAtPos = new THREE.Vector3(0,8.1,0);

    let modelIdx = 0;
    const modelFiles = [
        'models/mmd/kizunaai/kizunaai.pmx',
        'models/mmd/『天宮こころ(Kokoro Amamiya)』/『天宮こころ(Kokoro Amamiya)』.pmx',
        'models/mmd/るいのれ式物述有栖_配布用フォルダ/物述有栖.pmx'
    ];

    let modelData;
    let colors = {red: 0xff0000, green: 0x00ff00, purple: 0x9933ff, blue: 0x3399ff};
    let mouse = new THREE.Vector2();
    let mouseDownPos = new THREE.Vector2();
    let isMouseDown = false;

    Ammo().then(function (AmmoLib) {

        Ammo = AmmoLib;

        init();
        animate();

    });

    function init() {
        loadJSON('model_data.json', function (resp) {
            modelData = JSON.parse(resp).modellist;
            addEyeLines();
        });

        const container = document.createElement('div');
        document.body.appendChild(container);
        camera = new THREE.OrthographicCamera(0.5 * frustumSize * aspect / -2, 0.5 * frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
        camera2 = new THREE.OrthographicCamera(0.25 * frustumSize * aspect / -2, 0.25 * frustumSize * aspect / 2, 0.5 * frustumSize / 2, 0.5 * frustumSize / -2, 0.1, 1000);
        camera3 = new THREE.OrthographicCamera(0.25 * frustumSize * aspect / -2, 0.25 * frustumSize * aspect / 2, 0.5 * frustumSize / 2, 0.5 * frustumSize / -2, 0.1, 1000);
        camera4 = new THREE.OrthographicCamera(0.25 * frustumSize * aspect / -2, 0.25 * frustumSize * aspect / 2, 0.5 * frustumSize / 2, 0.5 * frustumSize / -2, 0.1, 1000);
        camera5 = new THREE.OrthographicCamera(0.25 * frustumSize * aspect / -2, 0.25 * frustumSize * aspect / 2, 0.5 * frustumSize / 2, 0.5 * frustumSize / -2, 0.1, 1000);

        camera.position.copy(cameraPos);
        camera2.position.copy(cameraPos);
        camera3.position.copy(cameraPos);
        camera4.position.copy(cameraPos);
        camera5.position.copy(cameraPos);

        // scene

        scene = new THREE.Scene();
        const ambient = new THREE.AmbientLight(0x666666);
        scene.add(ambient);

        const directionalLight = new THREE.DirectionalLight(0x887766);
        directionalLight.position.set(-1, 1, 1).normalize();
        scene.add(directionalLight);

        //

        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);
        renderer.autoClear = false;
        effect = new OutlineEffect(renderer);

        loadModel(0);

        //
        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('resize', onWindowResize);
        //鏡頭控制
    }

    function onMouseMove(event) {
        if (!isMouseDown) return;
        event.preventDefault();
        let dx = (event.clientX / window.innerWidth) * 2 - 1 - mouse.x;
        let dy = -(event.clientY / window.innerHeight) * 2 + 1 - mouse.y;
        rotateEye(dx, dy);
    }

    function onMouseDown(event) {
        if(event.button === 2) return;
        event.preventDefault();
        isMouseDown = true;
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    function onMouseUp(event) {
        event.preventDefault();
        isMouseDown = false;
    }

    function rotateEye(dx, dy) {
        mesh.skeleton.bones[88].rotation.x = -dy * 5;
        mesh.skeleton.bones[88].rotation.y = dx * 5;
    }

    function onKeyDown(event) {
        if (event.key === 'A' || event.key === 'a') {
            modelIdx = moveModelIdx(-1)
            loadModel(modelIdx);
        }

        if (event.key === 'D' || event.key === 'd') {
            modelIdx = moveModelIdx(1)
            loadModel(modelIdx);
        }
    }

    function addEyeLines() {
        let modelPoints = getModelPoints();

        let isHorizontal;

        let dy = (modelPoints[0].y - modelPoints[2].y) / 4
        let dx = (modelPoints[1].x - modelPoints[3].x) / 8

        let point = {x: 0, y: 0};

        let idx = 0;

        // draw horizontal lines
        isHorizontal = true;
        point.x = modelPoints[0].x;
        for (let i = 0; i <= 4; i++) {
            point.y = modelPoints[0].y - dy * i;
            addLine(`l${idx + 1}`, point, colors.green, isHorizontal);
            idx++;
        }

        // draw vertical lines
        isHorizontal = false;
        point.y = modelPoints[1].y;
        for (let i = 0; i <= 8; i++) {
            point.x = modelPoints[1].x - dx * i;
            addLine(`l${idx + 1}`, point, colors.red, isHorizontal);
            idx++;
        }
    }

    function getModelPoints() {
        let pointData = modelData[modelIdx];
        let propLocName = 'line_location'
        let propLocXName = '';
        let propLocYName = '';
        let points = []

        for (let i = 0; i < 4; i++) {
            propLocXName = `${propLocName}x_${i + 1}`;
            propLocYName = `${propLocName}y_${i + 1}`;
            points.push({x: pointData[propLocXName], y: pointData[propLocYName]});
        }

        return points
    }

    function addLine(name, points, color, isHorizontal) {
        let linePoints;
        let lineLength = 1;

        if (isHorizontal) {
            linePoints = [
                new THREE.Vector3(points.x - lineLength, points.y, 2),
                new THREE.Vector3(points.x + lineLength, points.y, 2)
            ]
        } else {
            linePoints = [
                new THREE.Vector3(points.x, points.y - lineLength, 2),
                new THREE.Vector3(points.x, points.y + lineLength, 2)
            ]
        }

        let line = new THREE.Line(
            new THREE.BufferGeometry().setFromPoints(linePoints),
            new THREE.LineBasicMaterial({
                color: color
            })
        );
        line.name = name;
        scene.add(line);
    }

    function moveModelIdx(offset) {
        return (modelIdx + offset + modelFiles.length) % modelFiles.length;
    }

    function loadModel(idx) {
        function onProgress(xhr) {
            if (xhr.lengthComputable) {
                const percentComplete = xhr.loaded / xhr.total * 100;
                console.log(Math.round(percentComplete, 2) + '% downloaded');
            }
        }

        let modelFile = modelFiles[idx];

        helper = new MMDAnimationHelper();

        const loader = new MMDLoader();

        loader.load(modelFile, function (object) {
            if (mesh !== null) scene.remove(mesh);

            mesh = object;
            mesh.position.y = -10;

            scene.add(mesh);

        }, onProgress, null);
    }

    function loadJSON(file, callback) {
        let xObj = new XMLHttpRequest();
        xObj.overrideMimeType("application/json");
        xObj.open('GET', file, true);
        xObj.onreadystatechange = function () {
            if (xObj.readyState === 4 && xObj.status === 200) {
                callback(xObj.responseText);
            }
        };
        xObj.send(null);
    }

    function onWindowResize() {

        SCREEN_WIDTH = window.innerWidth;
        SCREEN_HEIGHT = window.innerHeight;
        aspect = SCREEN_WIDTH / SCREEN_HEIGHT;

        effect.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

        camera.left = 0.5 * frustumSize * aspect / -2;
        camera.right = 0.5 * frustumSize * aspect / 2;
        camera.top = frustumSize / 2;
        camera.bottom = -frustumSize / 2;
        camera.updateProjectionMatrix();

        camera2.left = 0.25 * frustumSize * aspect / -2;
        camera2.right = 0.25 * frustumSize * aspect / 2;
        camera2.top = 0.5 * frustumSize / 2;
        camera2.bottom = -0.5 * frustumSize / 2;
        camera2.updateProjectionMatrix();

        camera3.left = 0.25 * frustumSize * aspect / -2;
        camera3.right = 0.25 * frustumSize * aspect / 2;
        camera3.top = 0.5 * frustumSize / 2;
        camera3.bottom = -0.5 * frustumSize / 2;
        camera3.updateProjectionMatrix();

        camera4.left = 0.25 * frustumSize * aspect / -2;
        camera4.right = 0.25 * frustumSize * aspect / 2;
        camera4.top = 0.5 * frustumSize / 2;
        camera4.bottom = -0.5 * frustumSize / 2;
        camera4.updateProjectionMatrix();

        camera5.left = 0.25 * frustumSize * aspect / -2;
        camera5.right = 0.25 * frustumSize * aspect / 2;
        camera5.top = 0.5 * frustumSize / 2;
        camera5.bottom = -0.5 * frustumSize / 2;
        camera5.updateProjectionMatrix();
    }

    function animate() {

        requestAnimationFrame(animate);
        render();

    }

    function render() {
        camera.lookAt(cameraLookAtPos);
        camera2.lookAt(cameraLookAtPos);
        camera3.lookAt(cameraLookAtPos);
        camera4.lookAt(cameraLookAtPos);
        camera5.lookAt(cameraLookAtPos);

        effect.clear();

        effect.setViewport(0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT);
        effect.render(scene, camera);

        effect.setViewport(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, SCREEN_WIDTH / 4, SCREEN_HEIGHT / 2);
        effect.render(scene, camera2);

        effect.setViewport(SCREEN_WIDTH / 2 + SCREEN_WIDTH / 4, SCREEN_HEIGHT / 2, SCREEN_WIDTH / 4, SCREEN_HEIGHT / 2);
        effect.render(scene, camera3);

        effect.setViewport(SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 4, SCREEN_HEIGHT / 2);
        effect.render(scene, camera4);

        effect.setViewport(SCREEN_WIDTH / 2 + SCREEN_WIDTH / 4, 0, SCREEN_WIDTH / 4, SCREEN_HEIGHT / 2);
        effect.render(scene, camera5);
    }
</script>

</body>

</html>