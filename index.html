<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - loaders - MMD loader</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <style>
        body {
            background-color: #fff;
            color: #444;
        }

        a {
            color: #08f;
        }
    </style>
</head>

<body>
<div id="info"></div>

<script src="js/libs/ammo.wasm.js"></script>
<script src="scoreoutputer.min.js"></script>
<script>
    // 建構子 ScoreOutputer 接受一個字串，該字串為 csv 的檔案名稱
    // 以下面範例，檔名就為 "109598105(總分: 6).csv"
    var so = new ScoreOutputer("110598045");
    so.installCSS(function () {
        // 安裝 bootstrap 的 css，如果在 html 上方引用 bootstrap 5.1.1 的話就不用使用 installCSS ，注意一定要 bootstrap css 5.1.1 版
        // installCSS 接收一個 callback 當作參數，作為成功安裝 bootstrap css 的回呼函式

        //加入項目，分數，完成狀況
        //第一個參數為 項目名稱
        //第2個參數為 項目分數
        //第3個參數為 完成狀況，有完成 true/未完成 false
        //有幾個項目就呼叫幾個 addChild
        //addChild 要比 renderModal 先呼叫
        so.addChild("繪製出 5 個畫面", 1, true);
        so.addChild("回答問題", 1, false);
        so.addChild("可按鍵選擇上 / 下一隻角色", 1, true);
        so.addChild("讀取作業 2 儲存的座標點在眼睛上繪製出分割線", 1, false);
        so.addChild("可選擇當下控制哪個虹膜", 1, false);
        so.addChild("按滑鼠左鍵控制虹膜移動，右鍵停止", 2, false);
        so.addChild("複製參數至對應目標參數", 2, false);
        so.addChild("可儲存虹膜轉動角度", 1, false);

        //產生自評表，參數如下所示
        so.renderModal(
            //1. 自評表插入位置 (預設 document.body)
            document.body,
            //2. 自評表背景 (預設紅色)
            'rgba(100,45,58,1)',
            //3. 自評表文字顏色 (預設白色)
            'white',
            //4. 自評表文字大小 (預設 14pt)
            '15pt',
            //5. 自評表 checkbox 文字大小 (預設多少忘了)
            '15px',
            //6. 自評表標題 (預設 "自我評分表")
            dialogTitle = "自我評分表"
        );

        //設定下載按鈕 <-- 一定要呼叫這個函數，不然沒有下載功能
        so.installDownloadBtn();

        //產生 "開啟自評表按鈕"
        so.renderBtn(
            //自評表按鈕插入位置
            document.querySelector("#info"),
            //自評表按鈕文字
            "開啟自評表"
        );
    });
</script>
<script type="module">

    import * as THREE from './build/three.module.js';
    import {GUI} from './jsm/libs/dat.gui.module.js';
    import {OrbitControls} from './jsm/controls/OrbitControls.js';
    import {OutlineEffect} from './jsm/effects/OutlineEffect.js';
    import {MMDLoader} from './jsm/loaders/MMDLoader.js';
    import {MMDAnimationHelper} from './jsm/animation/MMDAnimationHelper.js';

    let scene, renderer, effect;
    let mesh, helper;
    let SCREEN_WIDTH = window.innerWidth;
    let SCREEN_HEIGHT = window.innerHeight;
    let aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
    let frustumSize = 1.5;
    let cameras = []
    let cameraPos = new THREE.Vector3(0, 8.1, 3);

    let modelIdx = 0;
    const modelFiles = [
        'models/mmd/kizunaai/kizunaai.pmx',
        'models/mmd/『天宮こころ(Kokoro Amamiya)』/『天宮こころ(Kokoro Amamiya)』.pmx',
        'models/mmd/るいのれ式物述有栖_配布用フォルダ/物述有栖.pmx'
    ];

    let colors = {red: 0xff0000, green: 0x00ff00, purple: 0x9933ff, blue: 0x3399ff};
    let mouse = new THREE.Vector2();
    let mouseDownPos = new THREE.Vector2();
    let isMouseDown = false;

    let mainView;
    let subViews = []
    let viewIdx = 0;

    let modelPositions = [];
    let subCameraPositions = [];

    let modelEyeBoneIdxes = [];
    let modelEyeIdx = 0;

    Ammo().then(function (AmmoLib) {
        Ammo = AmmoLib;
        init();
        animate();
    });

    function init() {
        const container = document.createElement('div');
        document.body.appendChild(container);

        loadJSON('model_data.json', function (resp) {
            let modelData = JSON.parse(resp).modellist;
            addEyeLines(modelData);
        });

        modelEyeBoneIdxes = readModelEyeBoneIdxes();

        // read positions
        modelPositions = readModelPositions();
        subCameraPositions = readSubCameraPositions();

        // read view
        mainView = readMainView();
        subViews = readSubViews();

        // set main camera
        setMainCamera(viewIdx);

        // set sub camera positions
        setSubCameraPositions(subCameraPositions, modelIdx);

        // scene

        scene = new THREE.Scene();
        const ambient = new THREE.AmbientLight(0x666666);
        scene.add(ambient);

        const directionalLight = new THREE.DirectionalLight(0x887766);
        directionalLight.position.set(-1, 1, 1).normalize();
        scene.add(directionalLight);

        //

        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);
        renderer.autoClear = false;
        effect = new OutlineEffect(renderer);

        loadModel(modelIdx);

        //
        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('resize', onWindowResize);
        //鏡頭控制
    }

    function readModelEyeBoneIdxes(){
        return [
            [88, 86],
            [49, 51],
            [11, 13]
        ];
    }

    function readModelPositions(){
        return [
            [
                new THREE.Vector3(0, -10, 0),
                new THREE.Vector3(10, -10, 0),
                new THREE.Vector3(20, -10, 0),
                new THREE.Vector3(30, -10, 0)
            ],
            [
                new THREE.Vector3(0, -10, 0),
                new THREE.Vector3(10, -10, 0),
                new THREE.Vector3(20, -10, 0),
                new THREE.Vector3(30, -10, 0)],
            [
                new THREE.Vector3(0, -10, 0),
                new THREE.Vector3(10, -10, 0),
                new THREE.Vector3(20, -10, 0),
                new THREE.Vector3(30, -10, 0)
            ]
        ]
    }

    function readSubCameraPositions() {
        return [
            [
                new THREE.Vector3(0, 8.1, 3),
                new THREE.Vector3(10, 8.1, 3),
                new THREE.Vector3(20, 8.1, 3),
                new THREE.Vector3(30, 8.1, 3)
            ],
            [
                new THREE.Vector3(0, 8.1, 3),
                new THREE.Vector3(0, 8.1, 3),
                new THREE.Vector3(0, 8.1, 3),
                new THREE.Vector3(0, 8.1, 3)],
            [
                new THREE.Vector3(0, 8.1, 3),
                new THREE.Vector3(0, 8.1, 3),
                new THREE.Vector3(0, 8.1, 3),
                new THREE.Vector3(0, 8.1, 3)
            ]
        ]
    }

    function readMainView() {
        return {
            camera: null,
            viewport: {
                x: 0,
                y: 0,
                w: SCREEN_WIDTH / 2,
                h: SCREEN_HEIGHT
            }
        }
    }

    function readSubViews() {
        return [
            {
                camera: createOrthographicCamera(),
                model: null,
                viewport: {
                    x: SCREEN_WIDTH / 2,
                    y: SCREEN_HEIGHT / 2,
                    w: SCREEN_WIDTH / 4,
                    h: SCREEN_HEIGHT / 2
                }
            },
            {
                camera: createOrthographicCamera(),
                model: null,
                viewport: {
                    x: SCREEN_WIDTH / 2 + SCREEN_WIDTH / 4,
                    y: SCREEN_HEIGHT / 2,
                    w: SCREEN_WIDTH / 4,
                    h: SCREEN_HEIGHT / 2
                }
            },
            {
                camera: createOrthographicCamera(),
                model: null,
                viewport: {
                    x: SCREEN_WIDTH / 2,
                    y: 0,
                    w: SCREEN_WIDTH / 4,
                    h: SCREEN_HEIGHT / 2
                }
            },
            {
                camera: createOrthographicCamera(),
                model: null,
                viewport: {
                    x: SCREEN_WIDTH / 2 + SCREEN_WIDTH / 4,
                    y: 0,
                    w: SCREEN_WIDTH / 4,
                    h: SCREEN_HEIGHT / 2
                }
            }
        ]
    }

    function setMainCamera(viewIdx){
        mainView.camera = subViews[viewIdx].camera;
    }

    function setSubCameraPositions(subCameraPositions, modelIdx) {
        subViews.forEach(function (view, idx){
            view.camera.position.copy(subCameraPositions[modelIdx][idx]);
        });
    }

    function createOrthographicCamera() {
        return new THREE.OrthographicCamera(
            0.5 * frustumSize * aspect / -2,
            0.5 * frustumSize * aspect / 2,
            frustumSize / 2,
            frustumSize / -2,
            0.1,
            1000
        );
    }

    function onMouseMove(event) {
        if (!isMouseDown) return;
        event.preventDefault();
        let dx = (event.clientX / window.innerWidth) * 2 - 1 - mouse.x;
        let dy = -(event.clientY / window.innerHeight) * 2 + 1 - mouse.y;
        rotateEye(dx, dy);
    }

    function onMouseDown(event) {
        if (event.button === 2) return;
        event.preventDefault();
        isMouseDown = true;
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    function onMouseUp(event) {
        event.preventDefault();
        isMouseDown = false;
    }

    function rotateEye(dx, dy) {
        let eyeBoneIdx = modelEyeBoneIdxes[modelIdx][modelEyeIdx];
        subViews[viewIdx].model.skeleton.bones[eyeBoneIdx].rotation.x = -dy * 5;
        subViews[viewIdx].model.skeleton.bones[eyeBoneIdx].rotation.y = dx * 5;
    }

    function onKeyDown(event) {
        if (event.key === 'A' || event.key === 'a') {
            modelIdx = moveModelIdx(-1)
            loadModel(modelIdx);
        }

        if (event.key === 'D' || event.key === 'd') {
            modelIdx = moveModelIdx(1)
            loadModel(modelIdx);
        }

        if (event.key === '2') {
            moveEyeLines(1)
        }

        if (event.key === '1') {
            moveEyeLines(-1)
        }
    }

    function moveEyeLines(offset) {
        let eyeLength = 2;
        let nextModelEyeIdx = modelEyeIdx + offset;

        if (nextModelEyeIdx < 0 ){
            viewIdx = (viewIdx - 1 + subViews.length) % subViews.length
            modelEyeIdx = 1;
            setMainCamera(viewIdx);
            return;
        }

        if (nextModelEyeIdx > 1){
            viewIdx = (viewIdx + 1 + subViews.length) % subViews.length
            modelEyeIdx = 0;
            setMainCamera(viewIdx);
            return;
        }

        modelEyeIdx = (nextModelEyeIdx + eyeLength) % eyeLength;
    }

    function addEyeLines(modelData) {
        let modelPoints = getModelPoints(modelData);

        let isHorizontal;

        let dy = (modelPoints[0].y - modelPoints[2].y) / 4
        let dx = (modelPoints[1].x - modelPoints[3].x) / 8

        let point = {x: 0, y: 0};

        let idx = 0;

        // draw horizontal lines
        isHorizontal = true;
        point.x = modelPoints[0].x;
        for (let i = 0; i <= 4; i++) {
            point.y = modelPoints[0].y - dy * i;
            addLine(`l${idx + 1}`, point, colors.green, isHorizontal);
            idx++;
        }

        // draw vertical lines
        isHorizontal = false;
        point.y = modelPoints[1].y;
        for (let i = 0; i <= 8; i++) {
            point.x = modelPoints[1].x - dx * i;
            addLine(`l${idx + 1}`, point, colors.red, isHorizontal);
            idx++;
        }
    }

    function getModelPoints(modelData) {
        let pointData = modelData[modelIdx];
        let propLocName = 'line_location'
        let propLocXName = '';
        let propLocYName = '';
        let points = []

        for (let i = 0; i < 4; i++) {
            propLocXName = `${propLocName}x_${i + 1}`;
            propLocYName = `${propLocName}y_${i + 1}`;
            points.push({x: pointData[propLocXName], y: pointData[propLocYName]});
        }

        return points
    }

    function addLine(name, points, color, isHorizontal) {
        let linePoints;
        let lineLength = 1;

        if (isHorizontal) {
            linePoints = [
                new THREE.Vector3(points.x - lineLength, points.y, 2),
                new THREE.Vector3(points.x + lineLength, points.y, 2)
            ]
        } else {
            linePoints = [
                new THREE.Vector3(points.x, points.y - lineLength, 2),
                new THREE.Vector3(points.x, points.y + lineLength, 2)
            ]
        }

        let line = new THREE.Line(
            new THREE.BufferGeometry().setFromPoints(linePoints),
            new THREE.LineBasicMaterial({
                color: color
            })
        );
        line.name = name;
        scene.add(line);
    }

    function moveModelIdx(offset) {
        return (modelIdx + offset + modelFiles.length) % modelFiles.length;
    }

    function loadModel(idx) {
        function onProgress(xhr) {
            if (xhr.lengthComputable) {
                const percentComplete = xhr.loaded / xhr.total * 100;
                console.log(Math.round(percentComplete, 2) + '% downloaded');
            }
        }

        let modelFile = modelFiles[idx];

        helper = new MMDAnimationHelper();

        const loader = new MMDLoader();

        subViews.forEach(function (view, idx){
            loader.load(modelFile, function (object) {
                console.log(object.skeleton.bones);
                if (view.model !== null) scene.remove(view.model);
                view.model = object;
                view.model.position.copy(modelPositions[modelIdx][idx]);
                scene.add(object);
            }, onProgress, null);
        });
    }

    function loadJSON(file, callback) {
        let xObj = new XMLHttpRequest();
        xObj.overrideMimeType("application/json");
        xObj.open('GET', file, true);
        xObj.onreadystatechange = function () {
            if (xObj.readyState === 4 && xObj.status === 200) {
                callback(xObj.responseText);
            }
        };
        xObj.send(null);
    }

    function onWindowResize() {
        SCREEN_WIDTH = window.innerWidth;
        SCREEN_HEIGHT = window.innerHeight;
        aspect = SCREEN_WIDTH / SCREEN_HEIGHT;

        effect.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

        setViewSize(mainView);

        subViews.forEach(function (view) {
            setViewSize(view);
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        render();
    }

    function render() {
        effect.clear();

        setViewEffect(mainView);

        subViews.forEach(function (view) {
            setViewEffect(view);
        })
    }

    function setViewSize(view){
        view.camera.left = 0.5 * frustumSize * aspect / -2;
        view.camera.right = 0.5 * frustumSize * aspect / 2;
        view.camera.top = frustumSize / 2;
        view.camera.bottom = -frustumSize / 2;
        view.camera.updateProjectionMatrix();
    }

    function setViewEffect(view){
        effect.setViewport(
            view.viewport.x,
            view.viewport.y,
            view.viewport.w,
            view.viewport.h
        );
        effect.render(scene, view.camera);
    }
</script>

</body>

</html>